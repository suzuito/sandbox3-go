// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: article_search_indices.sql

package sqlcgo

import (
	"context"

	"github.com/google/uuid"
)

const upsertArticleSearchIndices = `-- name: UpsertArticleSearchIndices :many
WITH t1 AS (
  SELECT
    articles.id AS article_id,
    array_agg(rel_articles_tags.tag_id) AS tag_ids,
    articles.published_at AS published_at
  FROM articles
  LEFT JOIN rel_articles_tags ON articles.id = rel_articles_tags.article_id
  WHERE
    articles.deleted_at IS NULL
  GROUP BY articles.id, articles.published_at
  ORDER BY articles.created_at
  LIMIT $1 OFFSET $2
)
INSERT INTO articles_search_indices(article_id, tag_ids, published_at)
SELECT article_id, tag_ids, published_at FROM t1
ON CONFLICT(article_id)
DO UPDATE SET
  tag_ids = EXCLUDED.tag_ids,
  published_at = EXCLUDED.published_at
RETURNING article_id
`

type UpsertArticleSearchIndicesParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) UpsertArticleSearchIndices(ctx context.Context, arg UpsertArticleSearchIndicesParams) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, upsertArticleSearchIndices, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var article_id uuid.UUID
		if err := rows.Scan(&article_id); err != nil {
			return nil, err
		}
		items = append(items, article_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
